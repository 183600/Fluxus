{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE LambdaCase #-}

-- | Go lexical analyzer
module Fluxus.Parser.Go.Lexer
  ( -- * Token types
    GoToken(..)
  , GoKeyword(..)
  , GoOperator(..)
  , GoDelimiter(..)
    -- * Lexer
  , GoLexer
  , runGoLexer
  , lexGo
    -- * Individual token parsers
  , goKeyword
  , goIdentifier
  , goOperator
  , goDelimiter
  , goStringLiteral
  , goRuneLiteral
  , goNumberLiteral
  , goWhitespace
  , goComment
    -- * Utilities
  , isGoKeyword
  , goKeywordToText
  ) where

import Control.Monad (void)
import Data.Text (Text)
import qualified Data.Text as T
import Data.Char (isAlphaNum, isAlpha, isDigit)
import Data.Void (Void)
import qualified Text.Megaparsec as MP
import Text.Megaparsec.Char
import qualified Text.Megaparsec.Char.Lexer as L
import Text.Megaparsec (many, choice, try, notFollowedBy, optional, eof, getSourcePos, satisfy, takeWhileP, manyTill, anySingle, (<|>))
import Text.Megaparsec.Char (string)
import Control.Applicative ((<*), (*>))
import Data.Functor (($>))
import Data.Hashable (Hashable)
import GHC.Generics (Generic)
import Control.DeepSeq (NFData)

import Fluxus.AST.Common (SourcePos(..), SourceSpan(..), Located(..))

-- | Go token types
data GoToken
  = -- Keywords
    GoTokenKeyword !GoKeyword
    
  -- Identifiers and literals
  | GoTokenIdent !Text
  | GoTokenString !Text
  | GoTokenRawString !Text                              -- Raw string literals
  | GoTokenRune !Char
  | GoTokenInt !Text
  | GoTokenFloat !Text
  | GoTokenImag !Text                                   -- Imaginary numbers
  
  -- Operators and delimiters
  | GoTokenOperator !GoOperator
  | GoTokenDelimiter !GoDelimiter
  
  -- Whitespace and structure
  | GoTokenNewline
  | GoTokenComment !Text
  
  -- Special tokens
  | GoTokenEOF
  | GoTokenError !Text
  
  deriving stock (Eq, Ord, Show, Generic)
  deriving anyclass (Hashable, NFData)