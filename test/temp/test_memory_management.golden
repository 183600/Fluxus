Python Memory Management: __slots__, weakref, gc Module Demonstration
================================================================================
=== Testing __slots__ Memory Usage ===
Creating 10000 instances of each class...
Regular class:
  Creation time: 0.020s
  Approximate memory: 480,000 bytes
  Instance size: 48 bytes
Slotted class:
  Creation time: 0.021s
  Approximate memory: 560,000 bytes
  Instance size: 56 bytes
Memory savings: -16.7%

--- Testing Slot Restrictions ---
Allowed attributes: ['name', 'value', 'data']
name: test
value: 42
✓ Correctly prevented new attribute: 'SlottedClass' object has no attribute 'new_attribute' and no __dict__ for setting new attributes

=== Testing Slots Inheritance ===
Inherited slots: ['extra_field']
Name: test (from parent)
Value: 100 (from parent)
Extra field: extra_value (from child)
Instance size: 64 bytes
✓ Correctly prevented new attribute in inherited class: 'SlottedWithInheritance' object has no attribute 'another_new_attr' and no __dict__ for setting new attributes

=== Testing Weak References ===
Original objects: DataObject(100), DataObject(200)
Weak references: DataObject(100), DataObject(200)
Weak reference is alive: True
Weak reference value: 100
After deleting obj1:
Weak reference 1 is alive: False
Weak reference 2 is alive: True

--- Testing WeakValueDictionary ---
Weak dict before deletion: {'obj1': DataObject(300), 'obj2': DataObject(400)}
Weak dict after deleting obj1: {'obj2': DataObject(400)}

--- Testing WeakKeyDictionary ---
Weak key dict before deletion: {DataObject(key1): 'value1', DataObject(key2): 'value2'}
Weak key dict after deleting key1: {DataObject(key2): 'value2'}

=== Testing Garbage Collection ===
GC is enabled: True
GC thresholds: (2000, 10, 10)
Current GC count: (1, 0, 0)

Created circular reference: Node(1) -> Node(2) -> Node(3) -> Node(1)
GC disabled: True
Deleted all references to nodes with circular reference
Manually collected 10 objects
GC re-enabled: True

=== Testing Memory Profiling ===
Top memory allocations:
  /home/qwe12345678/hyperstatic2/test/python-tests/test_memory_management.py:255: size=3899 KiB (+3899 KiB), count=99745 (+99745), average=40 B
  /usr/lib/python3.13/tracemalloc.py:560: size=384 B (+384 B), count=2 (+2), average=192 B
  /usr/lib/python3.13/tracemalloc.py:423: size=376 B (+376 B), count=2 (+2), average=188 B
  /usr/lib/python3.13/tracemalloc.py:558: size=112 B (+56 B), count=2 (+1), average=56 B
  /usr/lib/python3.13/tracemalloc.py:313: size=48 B (+48 B), count=1 (+1), average=48 B

Current memory usage: 3.81 MB
Peak memory usage: 3.81 MB

=== Testing Object Lifecycle ===
Created: ManagedObject(first)
Created: ManagedObject(second)
Created: ManagedObject(third)
Active instances after creation: 3
Destroyed: ManagedObject(first)
Active instances after deletion: 2
Objects in weak set: 2
Destroyed: ManagedObject(second)
Objects in weak set after deletion: 1
Destroyed: ManagedObject(third)

=== Testing Memory Optimization Patterns ===
Average size per RegularPoint: 48.0 bytes
Average size per SlottedPoint: 48.0 bytes
Memory savings with slots: 0.0%

Object pool - Active: 2, Pool size: 0
After returning objects - Active: 0, Pool size: 2

=== Summary ===
Key concepts demonstrated:
1. __slots__ for memory optimization and attribute restriction
2. weakref for creating weak references that don't prevent garbage collection
3. gc module for manual garbage collection control
4. Memory profiling with tracemalloc
5. Object lifecycle management with weak references
6. Memory optimization patterns including object pooling

Best practices:
- Use __slots__ when creating many instances with fixed attributes
- Use weakref for caches and observer patterns to avoid circular references
- Monitor memory usage in production applications
- Implement proper cleanup in __del__ methods